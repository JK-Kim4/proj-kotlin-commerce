# 📄 문서: 미결제 주문 자동 취소 기능 구현 방안 비교 분석

## 1. 개요 (Overview)

본 문서는 이커머스 서비스에서 **'주문 생성 후 30분 동안 결제가 완료되지 않은 주문'** 에 대해 **자동으로 주문을 취소하고 상품 재고를 복구**하는 기능을 구현하기 위한 세 가지 기술적 방안을 비교 분석하는 것을 목표로 합니다.

-   **🎯 목표:** 안정적인 주문 취소 및 재고 복구 자동화
-   **핵심 과제:** 재고 데이터의 일관성 확보 및 불필요한 주문으로 인한 판매 기회 손실 방지

---

## 2. 핵심 평가 기준 (Key Evaluation Criteria)

각 기술 방안은 다음 다섯 가지 핵심 기준을 바탕으로 평가합니다.

-   **정확성/실시간성:** 취소 로직이 30분이라는 목표 시간에 얼마나 근접하게 실행되는가?
-   **안정성/신뢰성:** 서버 장애나 예외 상황 발생 시에도 누락 없이 작업을 처리할 수 있는가?
-   **확장성:** 서비스 트래픽이 증가했을 때 유연하게 대응할 수 있는가?
-   **DB 부하:** 데이터베이스에 미치는 부하가 어느 정도인가?
-   **구현 및 운영 복잡도:** 개발 및 유지보수에 드는 리소스는 어느 정도인가?

---

## 3. 구현 방안 상세 비교 (Detailed Comparison)

### 방안 1: 스케줄러(Scheduler)를 이용한 폴링 (Polling)

-   **⚖️ 한 줄 요약:** 가장 간단하지만, 서비스 규모가 커지면 비효율성이 증가하는 방식입니다.
-   **동작 원리:**
    1.  애플리케이션 스케줄러가 N분(예: 1분) 간격으로 실행됩니다.
    2.  `'결제 대기'` 상태이면서 생성된 지 30분이 지난 모든 주문을 DB에서 조회(`SELECT`)합니다.
    3.  조회된 주문들을 일괄적으로 '주문 취소' 처리하고 재고를 복구합니다.
-   **👍 장점:**
    -   **압도적으로 낮은 구현 복잡도:** 별도 인프라 없이 Spring `@Scheduled` 등으로 빠르게 구현 가능합니다.
    -   **단순한 로직:** 장애가 발생해도 다음 스케줄링 시점에 누락된 주문을 처리할 수 있습니다.
-   **👎 단점:**
    -   **높은 DB 부하:** 처리할 주문이 없어도 주기적으로 DB를 스캔하여 부하를 유발합니다.
    -   **낮은 정확성:** 취소 시간이 스케줄링 주기에 따라 최대 N분까지 지연될 수 있습니다.
    -   **낮은 확장성:** 주문량이 많아지면 단일 `UPDATE` 쿼리가 DB에 큰 부담을 줄 수 있습니다.

### 방안 2: 메시지 큐(Message Queue)를 이용한 지연 처리

-   **⚖️ 한 줄 요약:** 가장 안정적이고 확장성이 뛰어나지만, 초기 인프라 구축이 필요한 정석적인 방식입니다.
-   **동작 원리:**
    1.  주문이 생성될 때, 30분 지연 속성을 가진 메시지(주문 ID 포함)를 MQ(RabbitMQ, SQS 등)에 발행합니다.
    2.  MQ는 30분 동안 메시지를 보관 후, 지정된 소비자(Consumer)에게 전달합니다.
    3.  소비자는 메시지를 받아 해당 주문이 여전히 '결제 대기' 상태인지 확인 후 취소 및 재고 복구 로직을 실행합니다.
-   **👍 장점:**
    -   **높은 정확성 및 실시간성:** 30분이라는 시간에 거의 정확하게 작업이 트리거됩니다.
    -   **최소한의 DB 부하:** 불필요한 스캔 없이 필요한 시점에만 DB에 접근합니다.
    -   **뛰어난 안정성과 확장성:** 주문 로직과 취소 로직이 분리(Decoupling)되어 한쪽의 장애가 다른 쪽에 영향을 주지 않으며, 소비자 수를 늘려 대용량 트래픽에 쉽게 대응 가능합니다.
-   **👎 단점:**
    -   **높은 운영 복잡도:** RabbitMQ 등 별도 MQ 인프라 구축 및 운영, 모니터링이 필요합니다.
    -   **상대적으로 높은 초기 구현 비용:** 메시지 발행/소비 로직 구현이 필요합니다.

### 방안 3: Redis를 이용한 키 만료 이벤트 처리

-   **⚖️ 한 줄 요약:** MQ의 장점을 가볍게 구현할 수 있는 효율적인 대안이지만, Redis에 대한 의존성이 생깁니다.
-   **동작 원리:**
    1.  주문 생성 시, 30분의 만료 시간(TTL)을 가진 키(`order:cancel:주문ID`)를 Redis에 저장합니다.
    2.  Redis의 `Keyspace Notification` 기능을 활성화하여 키 만료 이벤트를 리스닝합니다.
    3.  30분 후 키가 만료되면, 이벤트 리스너가 이를 감지하여 해당 주문의 취소 및 재고 복구 로직을 실행합니다.
-   **👍 장점:**
    -   **높은 성능과 정확성:** In-memory 기반으로 매우 빠르고 정확한 시간 제어가 가능합니다.
    -   **가벼운 구현:** 이미 Redis를 사용 중이라면 MQ보다 적은 노력으로 유사한 효과를 낼 수 있습니다.
-   **👎 단점:**
    -   **Redis 의존성:** Redis 장애 시 이벤트가 유실될 수 있습니다. (RDB/AOF를 통한 복구도 완벽하지 않음)
    -   **중간 수준의 안정성:** 전문 MQ 시스템이 제공하는 메시지 보장, Dead Letter Queue 등의 고급 기능이 부족합니다.

---

## 4. 종합 비교표 (Summary Comparison Table)

| 평가 기준 | 방안 1: 스케줄러 | 방안 2: 메시지 큐 | 방안 3: Redis |
| :--- | :---: | :---: | :---: |
| **정확성/실시간성** | 낮음 (Low) | **높음 (High)** | **높음 (High)** |
| **안정성/신뢰성** | 중간 (Medium) | **높음 (High)** | 중간 (Medium) |
| **확장성** | 낮음 (Low) | **높음 (High)** | 중간 (Medium) |
| **DB 부하** | 높음 (High) | **낮음 (Low)** | **낮음 (Low)** |
| **구현 및 운영 복잡도**| **낮음 (Low)** | 높음 (High) | 중간 (Medium) |

---

## 5. 최종 제안 및 권장 사항 (Final Proposal)

> 조직의 현재 상황과 미래 성장 가능성을 종합적으로 고려하여 최적의 방안을 선택해야 합니다.

-   🚀 **초기 스타트업, 소규모 트래픽, 빠른 MVP 개발이 목표일 경우**
    -   **추천 방안: `방안 1: 스케줄러`**
    -   **사유:** 가장 빠르고 간단하게 기능을 구현하여 비즈니스 가치를 검증할 수 있습니다. 추후 서비스가 성장했을 때 `방안 2`로 마이그레이션하는 전략을 고려할 수 있습니다.

-   🏢 **중대규모 이상의 서비스, MSA 환경, 안정성과 확장성이 최우선일 경우**
    -   **추천 방안: `방안 2: 메시지 큐`**
    -   **사유:** 대용량 트래픽을 안정적으로 처리할 수 있는 가장 표준적이고 검증된 아키텍처입니다. 장기적인 관점에서 유지보수성과 확장성 면에서 가장 유리합니다.

-   💡 **이미 Redis를 핵심 인프라로 사용 중이며, MQ 도입이 부담스러운 경우**
    -   **추천 방안: `방안 3: Redis`**
    -   **사유:** 스케줄러의 단점인 DB 부하와 부정확성을 해결하면서, MQ보다는 가볍게 구현할 수 있는 현실적인 절충안입니다. 단, Redis 장애 시나리오에 대한 대비책을 마련해야 합니다.

---

## 6. 공통 고려사항 (Regardless of Choice)

어떤 방안을 선택하든 아래 두 가지는 반드시 구현에 포함되어야 합니다.

-   **트랜잭션(Transaction) 처리:** '주문 상태 변경'과 '재고 복구'는 반드시 하나의 원자적(Atomic) 단위로 묶여, 둘 중 하나라도 실패하면 모두 롤백되어야 데이터 정합성이 보장됩니다.
-   **멱등성(Idempotency) 확보:** 네트워크 오류 등으로 인해 취소 로직이 여러 번 실행되더라도, 재고가 중복으로 복구되는 등의 문제가 발생하지 않도록 로직을 설계해야 합니다. (예: 이미 '주문 취소' 상태이면 로직을 실행하지 않음)
